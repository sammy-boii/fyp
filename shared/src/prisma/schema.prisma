generator client {
  provider = "prisma-client"
  output   = "../prisma/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

enum NodeExecutionStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
}

enum WorkflowExecutionStatus {
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
}

enum TriggerType {
  MANUAL
  SCHEDULED
  WEBHOOK
}

model Workflow {
  id       String @id @default(cuid())
  authorId String
  author   User   @relation(fields: [authorId], references: [id])

  name        String
  description String?
  nodes       Json
  edges       Json

  isActive Boolean @default(false)

  executions WorkflowExecution[]

  schedule String? // cron expression

  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  lastExecutedAt DateTime?

  @@index([authorId])
  @@index([isActive, schedule])
}

model WorkflowExecution {
  id         String   @id @default(cuid())
  workflowId String
  workflow   Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)

  status WorkflowExecutionStatus @default(RUNNING)
  error  String?

  nodeExecutions NodeExecution[]

  triggerType TriggerType @default(MANUAL)
  duration    Int? // Execution time in ms

  completedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // FK are not indexed by default
  @@index([workflowId, createdAt]) // workflowId can be filtered individually or with createdAt but createdAt can't be filtered individually
  @@index([status])
}

model NodeExecution {
  id          String            @id @default(cuid())
  executionId String
  execution   WorkflowExecution @relation(fields: [executionId], references: [id], onDelete: Cascade)

  nodeId     String
  nodeType   String
  actionId   String
  config     Json
  outputData Json?
  error      String?

  status NodeExecutionStatus @default(PENDING)

  startedAt   DateTime?
  completedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([executionId])
  @@index([nodeId])
}

model User {
  id       String  @id @default(cuid())
  name     String
  email    String  @unique
  password String
  avatar   String?

  otp          String?
  otpExpiresAt DateTime?

  workflows   Workflow[]
  credentials OAuthCredential[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model OAuthCredential {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id])

  provider String
  service  String?
  notes    String?

  accessToken           String    @db.Text // strings are mapped to text by default
  refreshToken          String?   @db.Text
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scopes                String[]

  // Gmail Pub/Sub watch fields
  providerEmail        String? // The email address associated with this credential
  gmailHistoryId       String? // Last known history ID for tracking changes
  gmailWatchExpiration DateTime? // When the watch expires (renew before this)

  discordGuilds DiscordGuild[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // A user can only have one credential for a unique service from a unique provider
  @@unique([provider, service, userId])
  @@index([userId])
  @@index([providerEmail]) // For quick lookup when webhook arrives
}

// Track which Discord guilds a user has authorized the bot for
model DiscordGuild {
  id           String          @id @default(cuid())
  credentialId String
  credential   OAuthCredential @relation(fields: [credentialId], references: [id], onDelete: Cascade)

  guildId   String // Discord's guild ID
  guildName String? // Optional: store guild name for display without API call

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // A credential can only have one entry per guild
  @@unique([credentialId, guildId])
  @@index([credentialId])
}
